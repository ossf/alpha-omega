Gitlab support for Trusted Publishing is now officially in a public beta testing period. There is now a working prototype of Capslock for Rust. Code is being written for crates.io vulnerability surfacing. There is now a bunch of anomaly detection happening for crates.io.

## Trusted Publishing

[gitlab.com](https://gitlab.com/) support for Trusted Publishing is now officially in a [public beta testing](https://crates.io/docs/trusted-publishing) period. The plan is for developers who use GitLab to try Trusted Publishing and provide any actionable feedback. The expectation is that this will remain in beta until mid-January.

Tobias implemented a [flag](https://rust-lang.zulipchat.com/user_uploads/thumbnail/4715/jqdxvNjjyenlMlyzwuckqAHg/image.png/840x560.webp) to allow crate owners to [enforce](https://github.com/rust-lang/crates.io/issues/12361) Trusted Publishing for their specific crates.

crates.io Trusted Publishing can now be [configured](https://github.com/rust-lang/team/pull/2078) as IaC via the team repo for the crates owned by the Rust Project. Marco and other Rust Project infra team members have made configuring trusted publishing easier, more auditable and more reliable, as we can make sure that there are no drifts in the configuration.

There is now a [user id query parameter](https://github.com/rust-lang/crates.io/pull/12433) that allows users to avoid N+1 queries for Trusted Publishing configurations. Tobias added support for a `?user_id=123` query parameter to the Trusted Publishing config listing endpoints. This user ID only accepts the user ID of the currently authenticated user and will list the configurations of all the crates of which the user is an owner.

## Capslock

Adam has implemented a working prototype of a [Capslock](https://github.com/google/capslock) analyser for Rust projects, building on Walter's previous work on [painter](https://github.com/rustfoundation/painter) to perform static analysis using LLVM, and on Adam's previous crate analysis work to perform runtime analysis.

The next steps are to wrap everything up into a standalone tool and integrate the implementation with broader tooling for security advisories, which will use work from crates.io vulnerability surfacing.

## Vulnerability Surfacing

The crates.io vulnerability surfacing [RFC](https://github.com/rust-lang/rfcs/pull/3872) is moving into the Final Comment Period (FCP) stage. It just requires a few more approvals and then the RFC will hit its last approval stage.

On the assumption that the RFC will be approved. the implementation work has [begun](https://github.com/rust-lang/crates.io/pull/12311).

## Other Engineering

### Analytics

Walter has implemented crate and log analytics within DataDog. He is looking for anomalies across the top 500 crates. For example, if a crate has some task accomplished from an ip address that is not normally used for development of that crate, the it will be logged and flagged. There is also AI detection as well. We now are gathering and parsing metrics to see what AI user agents are doing against our crates.io APIs and what they are actually reading.

### Automating Foundation Infrastructure

Walter is building out Terraform for the Rust Foundation for things like user management. He is implementing CI/CD-based RBAC and enrollment for internal Foundation and Rust Innovation Lab projects.

## Announcements and Community

### C++/Rust Interop

Jon was involved in two proposals for the C++ standardization committee (WG21) which was presented at the recent meeting the first week of November. ["Safety Strategy Requirements for C++"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3874r0.pdf) proposes a concrete goal to direct future work starting immediately:

> There is no way to guarantee the safety of legacy C++ code, but developing a safe mode of operation could ensure C++ remains viable for new development if two key criteria are met:
> 1. Safety by construction: no undefined behavior without explicitly invoking unsafe code such as legacy C++
> 2. Backwards compatibility: direct access to existing C++

This goal would be enormously positive for Rust interoperability as well as safety and security in general considering that many billions of lines of C++ exist in ubiquitous systems. Despite being in an area which has seen little consensus to date, the proposal [received near unanimous consensus in the safety and security study group](https://github.com/cplusplus/papers/issues/2475). Many co-authors have signed on to support the next revision of the proposal which will be presented to the Evolution Working Group at the next meeting in March.

Another paper that Jon joined as a co-author was ["A Lifetime-Management Primitive for Trivially Relocatable Types"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3858r0.pdf), which aimed to provide the necessary support for storing C++'s "trivially relocatable" types on the Rust stack; a key requirement for high-performance interoperability. This was a new feature in C++26, but it [was removed entirely](https://rust-lang.zulipchat.com/#narrow/channel/427678-t-lang.2Finterop/topic/.E2.9C.94.20Trivial.20relocation.20facility.20has.20just.20been.20removed.20from.20.2E.2E.2E/with/555025072) during the meeting due to emergent developments which cast doubt on the overall design of a feature that has been [in development for over 10 years](https://www.youtube.com/watch?v=DZ0maTWD_9g). This feature remains an essential piece of the C++/Rust interop story and Jon will be pursuing a new approach to find consensus in the C++29 timeframe.

### The Rust repository is now using main

Through a huge community effort, the `rust-lang/rust` default branch was [renamed](https://github.com/rust-lang/rust/pull/148564) to `main`.
